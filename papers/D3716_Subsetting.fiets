Subsetting


| Document # | D3716R0 |
| Date | 2025-05-19 |
| Targeted subgroups | EWG, SG23 |
| Ship vehicle | C++29 |
| Reply-to | Peter Bindels <dascandy@gmail.com> |

> What does "-Wall" in "g++ -Wall test.cpp -o test" do?  -- It's short for "warn all"; it turns on (almost) all the warnings that g++ can tell you about. Typically a good idea, especially if you're a beginner, because understanding and fixing those warnings can help you fix lots of different kinds of problems in your code.

# Abstract

We propose to have a standard facility in C++ to define a subset of the language, and to enforce a subset of the language in a given environment.

# Prior art

[P1881, Epochs](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1881r1.html)
- An epoch could reduce the number of possibilities and the complexity of the language by forbidding a subset of the existing approaches
- The author of this paper has delivered C++ training to hundreds of people of different skill levels, and strongly believes that the complexity of topics such as variable initialization could be eradicated by using a mechanism like epochs. After explaining how to enable the latest epoch to students, the training could focus on a safe and logical subset of the latest standard that does not provide needlessly varied and complicated choices. Furthermore, students attempting to use unsafe constructs that they learned from C or poor C++ training material would be stopped by the compiler before introducing undefined behavior into their code.

[P3081, Profiles](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3081r1.pdf)
- Define standard enforced “profiles” that a conforming C++ implementation must enforce when enabled, notably bounds, type, and lifetime. This is in addition to any user-defined profiles.
- Each profile consists of rules. Each rule must be deterministically decidable at compile time (even if it results in injecting a check enforced at run time) and must be sufficiently efficient to implement in-the-box in the C++ compiler without unacceptable impact on compile time.
- Rules are portable and enforced in the C++ implementation, not in a separate tool such as a static analyzer.

[P3390, SafeC++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3390r0.html)
- A superset of C++ with a safe subset. Undefined behavior is prohibited from originating in the safe subset.
- The safe and unsafe parts of the language are clearly delineated. Users must explicitly leave the safe context to write unsafe operations.
- The safe subset must remain useful. If we get rid of a crucial unsafe technology, like unions and pointers, we should supply a safe alternative, like choice types and borrows. A safe toolchain is not useful if it’s so inexpressive that you can’t get your work done.

[P2759, DG OPINION ON SAFETY FOR ISO C++](https://wg21.link/p2759)
- Profiles package up several features to make it visible for a code region. Profiles do not limit code in such a way that it reduces the language expressivity like subsets do. We do recognize some domains can deal with subsets and are thus not opposed to a profile-specific subset. However, it is our opinion that subsetting is not a suitable solution for a general purpose language.

Reddit [Subset of C++](https://www.reddit.com/r/cpp/comments/ee3a48/subset_of_c/)
- ... is it possible to have a subset of modern C++. ... With such a massive focus on modern C++ and teaching people about all the RAII techniques, smart pointers, containers, STL, algorithms and so much more, is it possible to just have a subset of C++, which enforces these best practices by default and let people study only the new/modern aspects of C++ leaving behind the legacy versions?
- This idea comes up, if you ask me, surprisingly often.
- C++ can take leaf out of Rust's notebook. The language allows you to mark code as unsafe code which lets you do some C style coding. Similarly this subset of C++ can allow developers to mark code as legacy or some other keyword and proceed with it. 
- C/C++ is what actually backwards. Safe code should be the default to make writing safe programs effortless. Full freedom to do anything is what caused tons of these memory related vulnerabilities that plague any C/C++ software.

StackOverflow [Official C++ language subsets](https://stackoverflow.com/questions/3073642/official-c-language-subsets)
- I've been restricting myself to a very C-like subset of C++ features; namely, no classes/inheritance except complex and STL, templates only used for find/replace kinds of substitutions, and a few other things I can't put in words off the top of my head. I am wondering if there are any official or well-documented subsets of the C++ language that I could look at for reference (as well as rationale) when I go about picking and choosing which features to use.
- Google publishes its internal C++ style guide, which is often referred to as such a subset: [Google style guide](https://google.github.io/styleguide/cppguide.html)
- The SEI CERT C++ Coding Standard gives a list of rules for writing safe, reliable, and secure systems in C++14. This is not a subset of C++ per se, but as a coding standard like the other answers is a subset in effect by avoiding unsafe, undefined, or easily-misused features (including some common to C).
- How close is existing C/C++ code to a safe subset? [https://www.mdpi.com/2624-800X/4/1/1]
- Using a safe subset of C++ is a promising direction for increasing the safety of the programming language while maintaining its performance and productivity. In this paper, we examine how close existing C/C++ code is to conforming to a safe subset of C++. We examine the rules presented in existing safe C/C++ standards and safe C/C++ subsets.
- We find that raw pointers, unsafe casts, and unsafe library functions are used in both C/C++ code at large and in modern C++ applications. In general, C/C++ code at large does not differ much from modern C++ code, and continued work will be required to transition from existing C/C++ code to a safe subset of C++.

# Revision history

R1: 

- Remove ability to subset keywords. The keywords themselves are not the problem but the language construct they're used in, which requires more fine grained targeting. Example is `delete`, which has three different meanings, only one of which you'd try to remove.
- Add concrete syntax to remove features

# Existing subsetting of C++

- In hard-embedded setups, dynamic allocations are not allowed
- IAR long shipped a mode called "Embedded C++" that omitted half of C++
- GCC / Clang ship a "-fno-rtti -fno-exceptions" mode, that disable RTTI and exceptions
- Many people want to use the "without-C" subset of C++ 
- Library authors want to use the "C++17-compatible" subset, typically enabled with `-std=c++17`
- MISRA and AutoSAR users want to use the compliant subset
- C added Annex K, subsetting out undesired functions
- Microsoft Visual C++ added the C4996 warning, subsetting out undesired functions
- the Clang/GCC `-Wall -Werror` subset of C++
- the Clang/GCC `-Wall -Wextra -Werror` subset of C++
- the Clang/GCC `-Wall -Wextra -Wpedantic -Werror` subset of C++
- In "Modern C++", we want to avoid raw "new" and "delete" statements in user code

# Design principles

- Code either compiles and works identically to what it does without the subset, or it does not compile. There are no other possible outcomes.
- Subsets always combine orthogonally. There are no interactions between subsets, no changed behavior.
- The compiler and linker do not get any special knowledge or permissions from the existence of a subset in a part of the program.
- Subset specification is done by many different unrelated standard bodies and code owners.
- Suppressing a given subsetting rule must be portable without requiring arbitrarily-large suppression lists.

# Why is subsetting a thing we can and want to do?

- It does not change the meaning of any code

The only thing it allows is removing a construct, function, type or keyword from use. The only change a user can see to their program is that it is now ill-formed, with a specific indication where the given subset is violated.

- The majority of code is not trying to do most of the things the language can do

Most people have used an axe and a gun at some point in their life, but don't use axes or guns often. Similarly, most C++ code ends up relying on pointer arithmetic, but does not try do any pointer arithmetic by itself. Rules in subsets can be suppressed, allowing for a nearly-always rule to still be enabled.

- Subsets combine orthogonally

Subsets define specific actions that are disallowed. The sum of two subsets is the sum of their disallowed actions. If any subset disallows suppressing a given rule, the sum subset disallows suppressing that rule.

- It is common for people to subset the language, and dozens of subsets are in common use

Building with warnings-as-errors for a warning set, subsetting out the warning-causing constructs. Building in `-std=c++17` mode, subsetting out all C++20+ constructs. Building with `-fno-exceptions -fno-rtti`, disabling exceptions and RTTI.

- It is one part of the mosaic of changes needed to create a safe future C++ language

# How to subset

Define a subset by doing one or more of the following

- Disallow use of a specific type

```cpp
class [[profiles::remove(unicode, "type is unfixably broken, use re2 instead")]] regex { ... };
```

- Disallow specific function usage (ie, mark function as effectively =delete despite being defined properly)

```cpp
[[profiles::remove(unsafe, "use std::string")]]
char *strstr(const char *haystack, const char *needle);
```

- Disallow enumerated set of specific language actions (array decay, variadic function use, pointer arithmetic, ...)

```cpp
[[profiles::remove_rule(unsafe, pointer_arithmetic, "No pointer arithmetic is allowed")]];
```

If multiple removals are applied to a single defined entity then all of them need to be disabled for the entity to be usable. It is usually a better idea to define one removal, and to have multiple profiles indirect to the name under which it is removed. How such profiles interact and join is defined in the main profiles papers.

# Rules that can be removed under this proposal

## pointer_arithmetic: Addition expressions containing a pointer and an integral value are not allowed any more.

Pointer arithmetic can easily result in pointers outside the bounds of the original value, and is often unintended. For the vast majority of code it would help to have a blanket ban on pointer arithmetic, but some bits of code (specifically the wrapper classes similar to `vector` and `span`) must retain access to it to remain implementable.

```cpp
int* a = begin(),* b = end();
size_t count = b - a; // remains legal
int* c = a + 42; // illegal
```

## variadic_functions: C-style variadic functions cannot be called.

C-style variadic functions (as opposed to C++-style variadic templates) do not carry any type information whatsoever and rely on incantations of va_arg, va_start, va_end etc. The correct usage of va_arg is typically encoded in a format string, which needs to be available at compile time to do this check. If the string is available at compile time, it's better to use a variadic template with compile-time format string parsing (as in `<format>`) - while if the format string is not available at compile time, it is a very unsafe practice that relies on having the runtime format string match with the compile-time arguments perfectly - and even in these cases, current `<format>` is a better choice.

Declaring functions with variadic arguments remains valid; both to keep `printf`\'s declaration valid, and to keep allowing usage of the variadic functions\' very low priority in function overload selection.

```cpp
printf("Hello %s\n", argv[1]); // illegal
println("Hello {}\n", argv[1]); // legal
```

## operator_comma_overload: operator comma overloads cannot be declared.

Operator comma is an operator that is hard to spot as it uses the same comma that separates normal function arguments or template arguments. As such, overloading it in general is frowned upon and discouraged for all but a very select few cases.

```cpp
struct S {
  template <typename RHS>
  auto operator,(RHS&& rhs) { ... }  // illegal
};
```

## operator_unary_ampersand_overload: unary operator ampersand overloads cannot be declared.

This makes it confusing for people expecting to get the address of the object and dereferencing it again to get back to the object. The obvious-looking code `*&x` may do something completely different or fail to compile, and STL implementers already know to write this as `*addressof(x)` - but for regular users it's still better advice to never overload unary operator&.

```cpp
struct S {
  bool operator&() { return false; } // illegal
};
```

## operator_boolean_binary_overload: binary boolean operators overloads cannot be declared.

Binary boolean operators have short-circuit semantics, in that they do not execute their second argument if the first argument already defines the value for the expression. This is used very often in dependent chains, such as `if (p && p->value)`. Overloading either the binary `||` or binary `&&` operator causes it to change to a regular binary operator, and will execute the second expression prior to evaluating the binary boolean operator (as it needs to pass in the result of both halves). This is surprising behavior to many, that is easily avoided by disallowing the overloads.

```cpp
struct S {
  bool operator&&(bool rhs) { return rhs; } // illegal
};
```

## reinterpret_cast: reinterpret_cast usage is not allowed.

Reinterpret_cast is a subversion of the type system that is almost unusable in regular client code. In some implementation code it is required to handle storing (for example) pointers as integers, to use low bits of aligned pointers as tag bits etc. As such, all general code usage of it should not be present.

```cpp
int main() {
  float f = 3.14;
  return *reinterpret_cast<int*>(&f); // illegal. Also UB, but now does not compile.
}
```

## const_cast: const_cast usage is not allowed.

Const_cast is a tool that is intended for const correctness in a code base to be wide spread, while retaining interoperability with non-const correct code bases (such as those exposing a C-style API without thought for const). As such it should only be used on the borders of such interops, and in general code it should never be used.

## dynamic_cast: dynamic_cast usage is not allowed.

Dynamic_cast is a checked cast within a virtual inheritance tree. Written as `U* a; T* b = dynamic_cast<T*>(a);` it can be used for downcasts (where T is a subclass of U), upcasts (where T is a superclass of U) and cross-casts (where T and U are classes that do not have one another in their superclasses). Upcasts are always safe, and compilers typically replace the dynamic_cast invocation with the static result of it. Downcasts check if the actual type is derived from T and if so return the T* equivalent, otherwise returning a nullptr; Crosscasts are cases where the two types have no obvious relation, but allow for conversion from U to T if the actual type underlying the passed-in `a` does implement T somewhere uniquely in its inheritance tree.

In general, code bases tend not to use many dynamic casts, and if they do a large portion of them are upcasts (sampled in 2014, code base of 7M lines, contained 128 dynamic_cast's of which 123 were upcasts or guaranteed downcasts, 4 checked downcasts and 1 crosscast). It is considered by some a "design smell" in that a "good" design uses the virtual functions to abstract away differences, seeing a dynamic_cast as a piercing of that abstraction to look at the underlying type anyway.

In those code bases, it would be desirable to restrict usage of dynamic_cast in general code.

## raw_new_delete: calling new or delete, or array new or delete, are not allowed.

In "Modern C++" it is possible to write code that only uses types that manage heap allocations for you, keeping your own code base free of any new or delete calls. In code bases like this it is desirable to be able to disable raw new and delete calls, so that no user code ends up doing manual memory management, even inadvertently or as a "temporary quick hack". 

This does not disable creating operator new or operator delete overloads in classes, nor does it disable the ability to mark a function as `=delete`.

## repeated_comparison: calling any of `>`, `<`, `<=`, `>=`, `!=` or `==` with the result of a comparison (from the same list) is not allowed.

This prevents use of the output of operators that take two comparable types and that normally result in a boolean result, from being used as the input to a binary operator itself. Code like this is often written by accident as the mathematical notation looks like correct code and often even compiles cleanly. This might be a candidate for actual deprecation or removal altogether, and if so it should not remain a suppressible rule.

## binary_op_on_bool: calling binary `&` or `|`, or unary `~` on a boolean expression is not allowed.

Often people forget that there are binary and boolean variants of the `and` and `or` operations. The binary ones are sometimes misused for the boolean ones, both as a "clever" way to avoid short-circuiting, and as a way to circumvent the nonexistence of `&&=` and `||=` operators. These functions have well-defined behavior for this usage, but are usually not desired by being hard to read. 

## throw_non_std_exception: throwing anything that is not derived from std::exception is not allowed.

The C++ language allows throwing any expression as exception. Catching any exception however is done with the `...` syntax, that does not allow any introspection into the error. In most large code bases, throwing anything that is not derived from std::exception is considered bad, and it would be very nice if we could enforce this code-wide.

## no_goto: goto usage is not allowed.

Goto is a feature that stems from C time and that does not play well with most C++ features like RAII. If an object lifetime starts or ends between the goto point and the label it jumps to, the code is considered UB, which makes the statement itself hard to use meaningfully. In addition, it breaks structure of normal programming constructs somewhat similar to `break` and `continue`, except in an unstructured fashion making code harder to read.

## no_mixed_switch: the case labels for a switch statement must all be first-order children of the switch body.

In most code, switch cases are direct members of the switch statement itself. The language however does not require this, and some constructs have been created (and frowned upon actual use) that use this, specifically Duff's Device.

All of these cases can be avoided, and in nearly all code we want to prevent this from being written.

## no_empty_statement: empty statements are not allowed.

Not many people knowingly ever write empty statements, but they are somewhat regularly created by accident due to confusion about closing braces being a type declaration or a scope termination. As such, code is sometimes written that contains empty statements that serve no purpose but to confuse future authors. This rule disallows empty statements except in places where a compound-statement would also be accepted

```cpp
   struct S {
     int a;
     int b;
   }; // required for closing type definition
   S object;
   if (object.a > object.b) {
     return object.a;
   }; // useless empty statement, now illegal

   while (object.b--) ; // still legal empty statement
```

## no_wchar_t: usage of the type wchar_t is not allowed.

Many code bases try to write portable code, and wchar_t does not have very portable behavior or encoding between most current systems. As such, the type is effectively unused on most platforms while being (and remaining) a mainstay on Windows. 

## no_integer_promotion: the code may not result in integer promotion resulting in a type change

Some code bases adopt the style where wrapper types or other strong type wrappers are to be used instead of small integer types. As such there should never be a hidden integer promotion in that code base - and if there is one, it's a known bug. This approach needs this ability to flag any code that accidentally still does an integer promotion.

# Combining multiple removal rules under one name

Each removal is attached to a single profile name. When multiple removals are attached to a single profile name, they can only be switched on and off together. How profile names combine is a separate problem that is out of scope for this proposal. P3589 is the leading proposal for tackling this problem.

# Wording

To be written


