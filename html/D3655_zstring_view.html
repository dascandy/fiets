<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="dascandy/fiets">
<title>
std::cstring_view</title>
  <style type="text/css">
body {
  margin: 5em;
  font-family: sans-serif;
  hyphens: auto;
  line-height: 1.35;
}
ul {
  padding-left: 2em;
}
h1, h2, h3, h4 {
  position: relative;
  line-height: 1;
}
h1.title {
}
h2.subtitle {
}
h1.toc a, h2.toc a, h3.toc a, h4.toc a {
  text-decoration: none;
  color: #000000;
}
h1.toc a:hover, h2.toc a:hover, h3.toc a:hover, h4.toc a:hover {
  text-decoration: underline;
}
a.self-link {
  position: absolute;
  top: 0;
  left: calc(-1 * (3.5rem - 26px));
  width: calc(3.5rem - 26px);
  height: 2em;
  text-align: center;
  border: none;
  transition: opacity .2s;
  opacity: .5;
  font-family: sans-serif;
  font-weight: normal;
  font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
span.identifier {
  font-style: italic;
}
span.special {
  color: #bf003f;
}
span.keyword {
  color: #0030cf;
}
span.comment {
  color: #00c000;
}
span.new {
  text-decoration: underline;
  background-color: #00ff40;
}
div.code, span.code {
  font-family: Courier New, monospace;
  background-color: #e8e8e8;
  white-space: pre;
}
span.delete {
  text-decoration: line-through;
  background-color: #bf0303;
}
p.indent {
  margin-left: 50px;
}
p.quote {
  margin-left: 50px;
  border: 2px solid black;
  background-color: #f0f0e0;
}
table {
  border: 1px solid black;
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
  margin-top: 0.8em;
  text-align: left;
  hyphens: none; 
}
td, th {
  padding-left: 1em;
  padding-right: 1em;
  vertical-align: top;
}
th {
  border-bottom: 2px solid black;
  background-color: #f0f0f0;
}
</style>
</head>
<body>
<h1 class="title" style="text-align:center">std::cstring_view</h1><table><tbody><tr><td> Document # </td><td> P3655R3 </td></tr><tr><td> Date </td><td> 2025-10-05 </td></tr><tr><td> Targeted subgroups </td><td> LEWG, LWG </td></tr><tr><td> Ship vehicle </td><td> C++29 </td></tr><tr><td> Reply-to </td><td> Peter Bindels &lt;dascandy@gmail.com&gt; </td></tr><tr><td> </td><td> Hana Dusíková &lt;hanicka@hanicka.net&gt; </td></tr><tr><td> </td><td> Jeremy Rifkin &lt;jeremy@rifkin.dev&gt; </td></tr><tr><td> </td><td> Marco Foco &lt;marco.foco@gmail.com&gt; </td></tr><tr><td> </td><td> Alexey Shevlyakov &lt;aleshevl@gmail.com&gt; </td></tr></tbody></table><h1 data-number="1" id="Abstract"><span class="header-section-number">1</span> Abstract<a href="#Abstract" class="self-link"></a></h1><p>We propose a standard string view type that guarantees null-termination.</p><h1 data-number="2" id="Introduction"><span class="header-section-number">2</span> Introduction<a href="#Introduction" class="self-link"></a></h1><p>C++17 introduced <span class="code">std<span class="special">::</span>string_view</span>, a non-owning view of a continuous sequence of characters. It is cheap to use, offers fast operations, and replaced most uses of <span class="code"><span class="keyword">const</span> std<span class="special">::</span>string<span class="special">&amp;</span></span> or <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span> as function parameters.  The utility and interface of string views as well as the benefits of not having to do unnecessary <span class="code">strlen</span> calculations on C-style strings makes string view types highly desirable for working with strings in C++.</p><p>Unlike <span class="code"><span class="keyword">const</span> std<span class="special">::</span>string<span class="special">&amp;</span></span> and many but not all <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span>, <span class="code">std<span class="special">::</span>string_view</span> is not null-terminated. This allows it to have fast and cheap substring operations. However, this also means <span class="code">std<span class="special">::</span>string_view</span> is not a suitable replacement for either of the two aforementioned types whenever a null-terminated C-style string is needed. While most C++ code mostly interfaces with C++ code, it is not uncommon to need to use operating system calls, C interfaces, third-party library APIs, or even C++ standard library APIs which require null-terminated strings. Because of a lack of a desirable option for passing non-owned null-terminated strings, <span class="code">std<span class="special">::</span>string_view</span> parameters are none the less sometimes used today in cases where null-terminated strings are needed, calling <span class="code">std<span class="special">::</span>string_view<span class="special">::</span>data</span> to get a <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span>. This is, needless to say, very bug-prone.</p><p>For this reason, many C++ developers use custom <span class="code">cstring_view</span> or <span class="code">cstring_view</span> types which are guaranteed to be null-terminated. Its wide presence on Github with implementations from among others Microsoft, Google, and many smaller projects, indicates a wide support for the type. As it's a lingua franca type, it should be part of the standard C++ library.</p><h1 data-number="3" id="Revision-History"><span class="header-section-number">3</span> Revision History<a href="#Revision-History" class="self-link"></a></h1><h2 data-number="3.1" id="R0--February-2025"><span class="header-section-number">3.1</span> R0, February 2025<a href="#R0--February-2025" class="self-link"></a></h2><h2 data-number="3.2" id="R1--May-2025"><span class="header-section-number">3.2</span> R1, May 2025<a href="#R1--May-2025" class="self-link"></a></h2><ul><li>Update with new numbers about use on github.</li><li>Integrate SG16 feedback</li><li>Add approaches to prioritize or select a particular overload for multiple competing overloads of a function taking a string-like argument</li><li>Number constructor overloads for discussion ease</li><li>Add polls on char_traits and contained NULs</li></ul><h2 data-number="3.3" id="R2--June-2025"><span class="header-section-number">3.3</span> R2, June 2025<a href="#R2--June-2025" class="self-link"></a></h2><ul><li>Merge with P3710 from Marco Foco</li><li>Expand on constructor rationales</li></ul><h2 data-number="3.4" id="R3--October-2025"><span class="header-section-number">3.4</span> R3, October 2025<a href="#R3--October-2025" class="self-link"></a></h2><ul><li>Add revision history</li><li>Remove polls section that was created for Sofia, as we now have answers.</li><li>Narrow paper based on feedback from Sofia SG23 and LEWG</li><li>Add reference implementation on Beman Project</li><li>Expanded explanation on constructors</li><li>Removed nullptr constructor (novel, should be separate paper), added empty constructor (accidental omission)</li><li>Reword relation between string_view and cstring_view after information from Corentin Jabot about constructors being preferred over conversion operators</li><li>Expanded wording</li></ul><h1 data-number="4" id="Previous-Papers"><span class="header-section-number">4</span> Previous Papers<a href="#Previous-Papers" class="self-link"></a></h1><p>The idea of <span class="code">cstring_view</span> was present even in the original paper for <span class="code">string_view</span> (Sept 2012 - Feb 2014) <a href="N3921">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3921.html#null-termination</a>:</p><p class="quote">Another option would be to define a separate cstring_view class to represent null-terminated strings and let it decay to string_view when necessary. That's plausible but not part of this proposal.</p><p>An attempt was made in Feb 2019 to concretely propose the type (renamed to <span class="code">cstring_view</span>) with <a href="P1402">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1402r0.pdf</a>, but it failed to gain consensus in LEWGI at <a href="Kona">https://wiki.edg.com/bin/view/Wg21kona2019/P1402</a>. In fact, the discussion there concluded with "CONSENSUS: We will not pursue P1402R0 or this problem space." It is also worth noting that contracts were briefly contemplated in the minutes as a way of addressing the problem, however, contracts can't check for a null character safely as it wouldn't be part of the view. Similarly, other runtime checks for <span class="code">string_view</span> null-termination are off the table.</p><p>However, in 2024 <a href="P3081 Core safety profiles for C++26">https://wg21.link/p3081</a> was published which contains an aside regarding a null-terminated <span class="code">cstring_view</span> in section 8, noting:</p><p class="quote">This is one of the commonly-requested features from the <a href="GSL">https://github.com/microsoft/GSL</a> library that does not yet have a std:: equivalent. It was specifically requested by several reviewers of this work.</p><p>During the discussion, it was made clear that <span class="code">cstring_view</span> deserves attention on its own and it should not be happenstance introduced as part of an entirely different topic. While P3081 did not end up passing for reasons other than <span class="code">cstring_view</span>, it is another example of the utility being seen as desirable.</p><p>We also have <a href="P2996 Reflection for C++26">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r9.html</a>, which in its specification of functions returning a <span class="code">string_view</span> or <span class="code">u8string_view</span> tries its best to say it's actually supposed to be a <span class="code">cstring_view</span>, except without naming the type for existential reasons:</p><p class="quote">Any function in namespace std::meta that whose return type is string_view or u8string_view returns an object V such that <span class="code">V<span class="special">.</span>data<span class="special">()[</span>V<span class="special">.</span>size<span class="special">()]</span> <span class="special">==</span> <span class="special">'\</span>0<span class="special">'</span></span>.</p><p>As such, we do believe that there is both space for such a type, and a desire from multiple angles to have it defined in the standard library.</p><h1 data-number="5" id="Discussion-on-the-type"><span class="header-section-number">5</span> Discussion on the type<a href="#Discussion-on-the-type" class="self-link"></a></h1><h2 data-number="5.1" id="Reasons-to-have-the-type"><span class="header-section-number">5.1</span> Reasons to have the type<a href="#Reasons-to-have-the-type" class="self-link"></a></h2><p>Many functions right now whether C++ standard library calls, operating system calls, or third-party library calls require null-terminated C-style strings. Absent an efficient type that can represent a non-owning view of a null-terminated string, these functions must take either a <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span> and incur potential <span class="code">strlen</span> overhead, take a <span class="code"><span class="keyword">const</span> std<span class="special">::</span>string<span class="special">&amp;</span></span> and possibly superfluously copy and allocate, take a <span class="code">string_view</span> and make a copy, or haphazardly take a <span class="code">std<span class="special">::</span>string_view</span> with a fragile unenforceable contract that it is a view of a null-terminated string. Such a contract would be unenforceable because <span class="code"><span class="keyword">pre</span><span class="special">(</span>sv<span class="special">[</span>sv<span class="special">.</span>size<span class="special">()]</span> <span class="special">==</span> 0<span class="special">)</span></span> is potentially undefined behavior.</p><p>String views tend to start their life coming from a string literal or from a type that owns its internal buffer, often <span class="code">std<span class="special">::</span>string</span>. Both of these are places that can always create a <span class="code">cstring_view</span> instead, as they both know their data is inherently null terminated.</p><p>Strings are very often just passed along with a non-owning string type all the way to where they are used as data. Some of these potential uses, such as calling <span class="code">std<span class="special">::</span>ofstream<span class="special">::</span>write</span>, do not rely on the null terminator, but others, like <span class="code">std<span class="special">::</span>ofstream<span class="special">::</span>ofstream</span>, do. Using <span class="code">string_view</span> as the intermediate type loses the knowledge that a null terminator is already guaranteed to be present, requiring the developer to either make assumptions or make a copy. Another common use might be creating a stringstream from a string <a href="StackOverflow question">https://stackoverflow.com/questions/58524805/is-there-a-way-to-create-a-stringstream-from-a-string-view-without-copying-data</a>.</p><p>We do not have to look far for examples of <span class="code">std<span class="special">::</span>string_view</span> being used in bug-prone ways with APIs expecting null-terminators. Searching <span class="code"><span class="special">/\.</span>data<span class="special">\(\)/</span> string_view language<span class="special">:</span>c<span class="special">++</span> <span class="special">-</span>is<span class="special">:</span>fork</span> on GitHub code search turns up two examples on the first page:</p><p>From <a href="surge-synthesizer/shortcircuit-xt">https://github.com/surge-synthesizer/shortcircuit-xt/blob/ba6ea3a2e703e4fa0ed069427aa42b668699b624/libs/md5sum/demo.cc#L37</a></p><code><div class="code">std<span class="special">::</span>optional<span class="special">&lt;</span>std<span class="special">::</span>string<span class="special">&gt;</span> hash_file<span class="special">(</span><span class="keyword">const</span> std<span class="special">::</span>string_view <span class="special">&amp;</span>file_name<span class="special">)</span> <span class="special">{</span>
    <span class="keyword">auto</span> fd <span class="special">=</span> open<span class="special">(</span>file_name<span class="special">.</span>data<span class="special">(),</span> O_RDONLY<span class="special">);</span>
    <span class="special">...</span></div></code><p>From <a href="VisualGMQ/gmq_header">https://github.com/VisualGMQ/gmq_header/blob/cbc2853f391acc51ddd25a50d567cac404776413/log.hpp#L66</a></p><code><div class="code"><span class="keyword">void</span> log<span class="special">(</span>Level level<span class="special">,</span> std<span class="special">::</span>string_view funcName<span class="special">,</span> std<span class="special">::</span>string_view filename<span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> line<span class="special">,</span> Args<span class="special">&amp;&amp;</span><span class="special">...</span> args<span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span>level <span class="special">&lt;</span><span class="special">=</span> level_<span class="special">)</span> <span class="special">{</span>
        printf<span class="special">("[%</span>s<span class="special">][%</span>s<span class="special">][%</span>s<span class="special">][%</span>u<span class="special">]",</span> Level2Str<span class="special">(</span>level<span class="special">).</span>data<span class="special">(),</span> filename<span class="special">.</span>data<span class="special">(),</span> funcName<span class="special">.</span>data<span class="special">(),</span> line<span class="special">);</span>
        <span class="special">...</span></div></code><p>These two examples could be argued to be bad code or misuses of <span class="code">std<span class="special">::</span>string_view</span>, however, the fact that they are written reflects the desire for the ability to use string view types in such cases.</p><p>These problems are visible enough that we have targeted patches for specific instances of this problem in the standard - <a href="P2495">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2495r0.pdf</a> attempts to directly patch this specific example. The solution bypasses that the problem is that we're missing an unbroken type-safe chain of knowledge that the value being passed is or is not null-terminated.</p><p>The type effectively fills out the design space that exists around strings within C++. We started off with <span class="code">std<span class="special">::</span>string</span> as an owning string type, ambiguously being specified as having a null terminator or not, clarified in C++11 to definitely *have* a null terminator. C++14 added <span class="code">std<span class="special">::</span>string_view</span> to that set, offering a non-null-terminated non-owning string type. The type itself raises the question, should we add a non-null-terminated owning string type, and/or a null-terminated non-owning string type? We're proposing the last of these, leaving only the non-null-terminated owning string type as not present. We believe there is no situation to be written where a non-null-terminated owning string type would have a measurable benefit over the null-terminated owning string type that we have, and as such it is not worth the added complexity.</p><p>Without them we retain the question we had before - <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span>, <span class="code"><span class="keyword">const</span> std<span class="special">::</span>string<span class="special">&amp;</span></span> or <span class="code">string_view</span>? The first loses lots of type safety and potentially requires redundant <span class="code">strlen</span> computation elsewhere in the software, the second requires it to be a <span class="code">std<span class="special">::</span>string</span> but retains null-termination knowledge, the last offers the ability to send any string type constructible to a string_view, but loses any knowledge of null termination. For the common case of passing along "some string input" to a function that ends up requiring null termination, the proposed <span class="code">cstring_view</span> is the only type that properly captures it.</p><p>Since the first draft of this paper the use of <span class="code">cstring_view</span> and <span class="code">cstring_view</span> on Github has grown from 1.9k to 2.1k, indicating active use, and in many cases people adding new implementations of the type. Many contain the subtle bugs that we highlight in this paper, illustrating why it is a good idea to add the type to the standard.</p><h2 data-number="5.2" id="Reasons-not-to-have-the-type"><span class="header-section-number">5.2</span> Reasons not to have the type<a href="#Reasons-not-to-have-the-type" class="self-link"></a></h2><p>In an ideal world, we could actually fix the operating systems and third-party libraries to accept pointer-and-size strings in all places, removing the need for null termination to exist, and for null termination propagation to be relevant. Sometimes, in particular from environments where this may not be unrealistic in a subset, the argument is voiced that <span class="code">cstring_view</span> does not offer any benefits.</p><p>Adding the type complicates the type system around strings by having more options for string types. This is not as much of an argument as it seems, since for each site a single type is the most appropriate, and the only places that would differ are those where the difference can make a meaningful performance impact - ie, the exact kind of tight loop where the type is useful for being able to make the difference.</p><h1 data-number="6" id="Design-rationale"><span class="header-section-number">6</span> Design rationale<a href="#Design-rationale" class="self-link"></a></h1><h2 data-number="6.1" id="cstring_view-and-string_view-relation"><span class="header-section-number">6.1</span> cstring_view and string_view relation<a href="#cstring_view-and-string_view-relation" class="self-link"></a></h2><p><span class="code">cstring_view</span> should be transparently convertible to a <span class="code">string_view</span>. There are multiple ways to create this conversion:</p><p>1. Implementing cstring_view as a subclass of string_view</p><p>2. Implementing string_view as subclass of cstring_view</p><p>3. Adding a conversion operator from cstring_view to string_view</p><p>4. Adding a constructor to string_view from cstring_view</p><p>For 1 and 2, the main question is if either of these types has a set of properties that is a strict subset of the other (ie, LSP). cstring_view has a guarantee that string_view does not uphold, so string_view cannot inherit publicly from cstring_view. However, string_view offers an operator= from string_view, which cstring_view cannot support, so cstring_view cannot inherit publicly from string_view either. That leaves the latter two strategies, and preference is given to the constructor approach.</p><p>This brings into reality an overload ambiguity:</p><code><div class="code">  <span class="keyword">void</span> handle<span class="special">(</span>string_view v<span class="special">);</span>
  <span class="keyword">void</span> handle<span class="special">(</span>cstring_view v<span class="special">);</span>
  handle<span class="special">("</span>Hello World<span class="special">!");</span></div></code><p>This is now an ambiguous function call. It is not a new problem; <a href="Example on Godbolt">https://godbolt.org/z/c31e31fKW</a> shows that the exact same problem already happens with regular <span class="code">std<span class="special">::</span>string</span> and <span class="code">std<span class="special">::</span>string_view</span>. The reason is somewhat fundamental; all three types model the concept "string" and *are* ambiguous. The user should be clear about which properties of string it's expecting. Adding this new type only adds to the vocabulary the option to say "non-owning null-terminated", giving the user better choices rather than complicating it.</p><h3 data-number="6.1.1" id="Deprioritizing-one-overload"><span class="header-section-number">6.1.1</span> Deprioritizing one overload<a href="#Deprioritizing-one-overload" class="self-link"></a></h3><p>When one overload is preferred, but others should exist, the less preferred ones can be marked with <span class="code">requires <span class="keyword">true</span></span>. This lifts one overload up out of the overload set for ambiguous matches, while leaving the rest to exist.</p><h3 data-number="6.1.2" id="Tag-type-forced-conversions-for-exact-matches"><span class="header-section-number">6.1.2</span> Tag type forced conversions for exact matches<a href="#Tag-type-forced-conversions-for-exact-matches" class="self-link"></a></h3><p><a href="https://godbolt.org/z/8qssnq8rf">https://godbolt.org/z/8qssnq8rf</a> and <a href="https://godbolt.org/z/xG7955hf9">https://godbolt.org/z/xG7955hf9</a> illustrate the idea of using a wrapping template to make one overload stand out.</p><h3 data-number="6.1.3" id="Explicitly-adding-a-function-to-disambiguate-manually"><span class="header-section-number">6.1.3</span> Explicitly adding a function to disambiguate manually<a href="#Explicitly-adding-a-function-to-disambiguate-manually" class="self-link"></a></h3><p><a href="https://godbolt.org/z/9zoGEh1cv">https://godbolt.org/z/9zoGEh1cv</a> demonstrates adding an overload that matches anything that isn't an exact match, which indirects to a function that hand-picks an overload.</p><h2 data-number="6.2" id="Construction"><span class="header-section-number">6.2</span> Construction<a href="#Construction" class="self-link"></a></h2><p><span class="code">std<span class="special">::</span>basic_string_view</span> offers a handful of constructors. The principle behind which to support is that if we can match the interface of <span class="code">string</span>, we should, and if not, if we can support the behavior of <span class="code">string_view</span> we should.</p><code><div class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">();</span> <span class="special">// (0)</span></div></code><p>Creates a <span class="code">cstring_view</span> that refers to a static null terminator. <span class="code">data<span class="special">()</span></span> and <span class="code">c_str<span class="special">()</span></span> are valid to call and result in a zero-length string, <span class="code">size<span class="special">()</span></span> returns zero. Behavior matches <span class="code">string</span>.</p><code><div class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">);</span> <span class="special">// (1)</span></div></code><p>The basic constructor from an unadorned <span class="code">charT<span class="special">*</span></span> risks taking a non-null-terminated string and searching for the null terminator. For <span class="code">cstring_view</span> this constructor is as safe as it is for <span class="code">string_view</span>, since we need to have a null terminator anyway.</p><code><div class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">,</span> size_type len<span class="special">);</span> <span class="special">// (2)</span></div></code><p>This constructor conceptually offers a O(1) construction time. For cstring_view we add a contract that asserts that <span class="code">str<span class="special">[</span>len<span class="special">]</span> <span class="special">==</span> <span class="special">'\</span>0<span class="special">'</span></span>. The behavior is logically identical to <span class="code">string</span> except that we require str<a href="len">len</a> to be dereferenceable and to dereference to a nul terminator.</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> It<span class="special">,</span> <span class="keyword">class</span> End<span class="special">&gt;</span>
<span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span>It begin<span class="special">,</span> End end<span class="special">);</span> <span class="special">// (3)</span></div></code><p>This constructor looks more difficult to support, but <span class="code">string_view</span>'s requirements on this constructor make it possible to support in the same fashion. From the action of creating a <span class="code">cstring_view</span> we get the implication from the user that the iterators are contiguous and point to a sized range, and that it must be nul-terminated. We specify the contract that <span class="code"><span class="special">*(</span>begin <span class="special">+</span> <span class="special">(</span>end <span class="special">-</span> begin<span class="special">))</span> <span class="special">==</span> <span class="special">'\</span>0<span class="special">'</span></span>, and that the contiguous range specified from begin must be dereferenceable in <span class="code"><span class="special">[</span>begin <span class="special">...</span> <span class="special">(</span>begin <span class="special">+</span> <span class="special">(</span>end <span class="special">-</span> begin<span class="special">))]</span></span>.</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> R<span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">explicit</span> basic_cstring_view<span class="special">(</span>R<span class="special">&amp;&amp;</span> r<span class="special">);</span> <span class="special">// (4)</span></div></code><p>This constructor has the same implication as (3) in that the range passed in must end with a nul terminator. The ability to check <span class="code">data<span class="special">()[</span>size<span class="special">()]</span></span> is rare, but is specified on <span class="code">string</span>. If we have any other range though, they are always specified in being dereferenceable only from <span class="code">0</span> to <span class="code">size<span class="special">()-</span>1</span>, but not at <span class="code">size<span class="special">()</span></span>. We keep this constructor with a requirement on the type <span class="code">R</span> that it satisfies the concept of having a nul terminator at <span class="code">size<span class="special">()</span></span>, and being dereferenceable.  - or do we want a requirement that it has a c_str function? Either way, restrict it on the concept of what it needs to work.</p><h2 data-number="6.3" id="Member-functions-on--string_view--that-return-a--string_view-"><span class="header-section-number">6.3</span> Member functions on `string_view` that return a `string_view`<a href="#Member-functions-on--string_view--that-return-a--string_view-" class="self-link"></a></h2><p>In some cases the functions can be replicated on <span class="code">cstring_view</span> with the return type being a <span class="code">cstring_view</span>, while in some cases the return type loses the ability to guarantee null termination, and should still return a <span class="code">string_view</span>. The types are entangled. Note that the user can always treat the return values as-if they were <span class="code">string_view</span> as the type is implicitly convertible; this is strictly giving the user more expressivity rather than less.</p><h3 data-number="6.3.1" id="-substr-"><span class="header-section-number">6.3.1</span> `substr`<a href="#-substr-" class="self-link"></a></h3><p>The <span class="code">substr</span> function is changed from a single function with a default argument, to two functions, one with one and one with two arguments. The one-argument <span class="code">substr</span> always retains the end (identical to <span class="code">string_view</span>'s <span class="code">substr</span>) and returns a <span class="code">cstring_view</span>; the two-argument <span class="code">substr</span> at least in a conceptual sense chops off at least the null terminator from the end, and should always return a <span class="code">string_view</span>. If the user cares about this difference they can assign to a <span class="code">cstring_view</span> and get a compile error if their call is incompatible. If they assign to a <span class="code">string_view</span> the behavior is identical to what <span class="code">string_view</span> would have done.</p><h3 data-number="6.3.2" id="-subview-"><span class="header-section-number">6.3.2</span> `subview`<a href="#-subview-" class="self-link"></a></h3><p>The <span class="code">subview</span> function is newly added in the 2025 Sofia meeting, which always creates a view on a part of the input string. In this paper we treat it the same as the <span class="code">substr</span> function and create a cstring_view if we can maintain the null termination guarantee, or create a string_view if we cannot statically maintain the guarantee. There is an adjoint paper (P3862) that proposes to fix this in the existing-but-unpublished C++26 standard to avoid future deviation in having <span class="code">std<span class="special">::</span>string<span class="special">::</span>subview</span> return <span class="code">string_view</span> for <span class="code">subview<span class="special">(</span>n<span class="special">)</span></span>.</p><h3 data-number="6.3.3" id="-remove_prefix-"><span class="header-section-number">6.3.3</span> `remove_prefix`<a href="#-remove_prefix-" class="self-link"></a></h3><p><span class="code">remove_prefix</span> drops characters from the front of the string it's called on. Behavior fits.</p><h3 data-number="6.3.4" id="-remove_suffix-"><span class="header-section-number">6.3.4</span> `remove_suffix`<a href="#-remove_suffix-" class="self-link"></a></h3><p><span class="code">remove_suffix</span> changes the string in-situ, and as such is unimplementable on cstring_view. It should be a function marked as =delete with a reason pointing users to use the two-argument <span class="code">substr</span> function instead, which returns a <span class="code">string_view</span>.</p><h2 data-number="6.4" id="Embedded-NUL-bytes"><span class="header-section-number">6.4</span> Embedded NUL bytes<a href="#Embedded-NUL-bytes" class="self-link"></a></h2><p>The practice of having an embedded NUL character in a <span class="code">string</span> or <span class="code">string_view</span> is very uncommon, and many developers do not consider such strings when writing their code. The use case of having a null-terminated string is much more common, in particular in interaction with C APIs (such as OS APIs, things like the Yubico libfido2 library, libsqlite and others). We have the option of forbidding and/or checking for embedded NULs in <span class="code">cstring_view</span>.</p><p>+ Prevents runtime shorter actual string length</p><ul><li>Creates unnecessary incompatibility with <span class="code">string</span> and <span class="code">string_view</span></li><li>Makes conversion from <span class="code">string</span> to <span class="code">string_view</span> different from conversion from <span class="code">string</span> through <span class="code">cstring_view</span> to <span class="code">string_view</span>.</li><li>Adds an O(n) check to all O(1) constructor</li><li>Actual prevalence of problem being prevented is minimal</li></ul><p>We do not propose to forbid embedded NUL bytes, keeping the type aligned with <span class="code">string</span> and <span class="code">string_view</span>. The existence of embedded NUL bytes is a separate topic and should be handled in a separate paper. Note that even the C++ standard itself has embedded NULs in some of its <span class="code">string</span> values, for example in <span class="code"><span class="special">[</span>facet<span class="special">.</span>numpunct<span class="special">.</span>virtuals<span class="special">]/</span>3</span> <span class="code">do_grouping</span>.</p><h2 data-number="6.5" id="Lazy-size-calculation"><span class="header-section-number">6.5</span> Lazy size calculation<a href="#Lazy-size-calculation" class="self-link"></a></h2><p>The type is used to carry the type-wise annotation that an existing allocated string is null-terminated to a place that needs this information. <span class="code">string</span> and <span class="code">string_view</span> eagerly calculate the size and store it. Both of these types are typically used in C++-style usage and need the size to check bounds, as well as to provide the user with size information with the <span class="code">size<span class="special">()</span></span> function.</p><p>For <span class="code">cstring_view</span>, it can be argued that the main use of the type is to eventually still have the type-wise knowledge that <span class="code">c_str<span class="special">()</span></span> exists and gives a null-terminated string, and that use as a C++-style string is secondary. In that same argument, eager calculation of <span class="code">size<span class="special">()</span></span> is of no value, since the user expects only to call <span class="code">c_str<span class="special">()</span></span> eventually, getting less or no benefit from the <span class="code">size<span class="special">()</span></span> calculation other than the safety guarantee that on construction the value was nul-terminated.</p><p>To enable this, we change the (1) constructor to be O(1) and to set the internal size to a static invalid value. The <span class="code">size<span class="special">()</span></span> function changes to amortized O(1) and on first call stores the calculated size in the member value. All other functions that rely directly or indirectly on <span class="code">size<span class="special">()</span></span> being O(1) are changed to being amortized O(1). We lose the ability to put contracts that have anything to do with the size on any function. The constructor cannot check that it's indeed a valid range with a null terminator. Operator<a href=""></a> can check that it's within range in a hardened precondition and has to be demoted to amortized O(1), or it stays O(1) and we cannot add that precondition as hardened.</p><p>The change seems strongly related to whether the language we're writing is C or C++ first. If we're writing C, then we should be opting for the direction that does not calculate size eagerly, and potentially not at all. If we're writing C++, the solution in line with what C++26 has added for hardened preconditions is to accept the size calculation. Users that really cannot afford that are still able to use <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span> to get the absolute highest performance.</p><h2 data-number="6.6" id="Conversion-from-string-being-explicit-"><span class="header-section-number">6.6</span> Conversion from string being explicit?<a href="#Conversion-from-string-being-explicit-" class="self-link"></a></h2><p>The rationale for this would be that a <span class="code">string</span> can contain embedded NULs, and this would make explicit that we're switching to a type that really doesn't like those. The downside of this is that we are introducing needless friction into the most common usage path, where the vast majority of users never use strings with embedded NULs.</p><h2 data-number="6.7" id="Modifying-the-cstring_view-or-underlying-storage"><span class="header-section-number">6.7</span> Modifying the cstring_view or underlying storage<a href="#Modifying-the-cstring_view-or-underlying-storage" class="self-link"></a></h2><p><span class="code">string_view</span> itself does not allow modifying the values through its interface and <span class="code">cstring_view</span> should not deviate from this. <span class="code">string_view</span> only states that the underlying storage must outlive the <span class="code">string_view</span> built on it, and <span class="code">cstring_view</span> will do the same, with the addition that the null terminator that it requires may not be modified, otherwise we get library UB. Adding or removing a NUL inside of the string has the same behavior as it does in string_view - you get an embedded NUL. That is a thing we can work to prevent, in a separate paper.</p><h2 data-number="6.8" id="Standard-Library-Changes"><span class="header-section-number">6.8</span> Standard Library Changes<a href="#Standard-Library-Changes" class="self-link"></a></h2><p>There are a handful of interfaces in the standard library which take <span class="code"><span class="keyword">const</span> string<span class="special">&amp;</span></span> and really want a <span class="code">cstring_view</span> or possibly a <span class="code">string_view</span>. These include:</p><ul><li>Constructors for stdexcept types, <span class="code">system_error</span>, <span class="code">format_error</span>, <span class="code">ios_base<span class="special">::</span>failure</span>, and <span class="code">std<span class="special">::</span>filesystem<span class="special">::</span>filesystem_error</span></li><li>The <span class="code">stoi</span> family of functions</li><li><span class="code">random_device<span class="special">::</span>random_device</span></li><li>Lots of locale interfaces</li><li><span class="code">basic_filebuf<span class="special">::</span>open</span>, <span class="code">basic_ifstream<span class="special">::</span>basic_ifstream</span>, <span class="code">basic_ifstream<span class="special">::</span>open</span>, <span class="code">basic_ofstream<span class="special">::</span>basic_ofstream</span>, <span class="code">basic_ofstream<span class="special">::</span>open</span>, <span class="code">basic_fstream<span class="special">::</span>basic_fstream</span>,  and <span class="code">basic_fstream<span class="special">::</span>open</span></li></ul><p>There are further interfaces which take <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span> and could have overloads taking a <span class="code">cstring_view</span> or <span class="code">string_view</span>.</p><p>We do not propose any such changes in this paper but would like to investigate this in a follow-up paper.</p><h2 data-number="6.9" id="Reference-Implementation"><span class="header-section-number">6.9</span> Reference Implementation<a href="#Reference-Implementation" class="self-link"></a></h2><p>A reference implementation is at <a href="Beman Project">https://github.com/bemanproject/cstring_view</a>.</p><h1 data-number="7" id="Historically-relevant-information"><span class="header-section-number">7</span> Historically relevant information<a href="#Historically-relevant-information" class="self-link"></a></h1><h2 data-number="7.1" id="Bikeshedding"><span class="header-section-number">7.1</span> Bikeshedding<a href="#Bikeshedding" class="self-link"></a></h2><p>Null-terminated string view types are typically named <span class="code">zstring_view</span> (N3921, P3081, GSL) or <span class="code">cstring_view</span> (P1402). <span class="code">cstring_view</span> follows the <span class="code">std<span class="special">::</span>string<span class="special">::</span>c_str<span class="special">()</span></span> nomenclature while <span class="code">zstring_view</span> has some establishment and recognizability.</p><p>Github code search shows similar popularity between <a href="`cstring_view`">https://github.com/search?q=%2F%5Cbcstring_view%5Cb%2F%20language%3Ac%2B%2B%20-is%3Afork&type=code</a> (1.2k results as of the time of writing) and <a href="`zstring_view`">https://github.com/search?q=%2F%5Cbzstring_view%5Cb%2F+language%3Ac%2B%2B+-is%3Afork&type=code</a> (680 results as of the time of writing). In refreshing this paper, it appears that cstring_view has gained ~200 added results, while zstring_view only added 8, hinting at a popular preference for the former name. In the October 2025 update, cstring_view has gained another 300 results, with zstring_view gaining 208.</p><p>The paper proposes cstring_view, as it has minor number advantage in every measurement so far.</p><h2 data-number="7.2" id="Prior-Polls"><span class="header-section-number">7.2</span> Prior Polls<a href="#Prior-Polls" class="self-link"></a></h2><h3 data-number="7.2.1" id="April-2025--Online-SG16"><span class="header-section-number">7.2.1</span> April 2025, Online SG16<a href="#April-2025--Online-SG16" class="self-link"></a></h3><h4 data-number="7.2.1.1" id="Poll-1--P3655R0--No-objection-to-use-of-std--char_traits-for-consistency-and-compatibility-with-std--string_view-"><span class="header-section-number">7.2.1.1</span> Poll 1: P3655R0: No objection to use of std::char_traits for consistency and compatibility with std::string_view.<a href="#Poll-1--P3655R0--No-objection-to-use-of-std--char_traits-for-consistency-and-compatibility-with-std--string_view-" class="self-link"></a></h4><p>Attendees: 8 (no abstentions)</p><p>7/1/0/0/0</p><p>Strong consensus.</p><p>    </p><h4 data-number="7.2.1.2" id="Poll-2--P3655R0--Forward-to-LEWG-with-encouragement-to-add-analysis-of-overload-resolution-and-techniques-to-address-ambiguity-"><span class="header-section-number">7.2.1.2</span> Poll 2: P3655R0: Forward to LEWG with encouragement to add analysis of overload resolution and techniques to address ambiguity.<a href="#Poll-2--P3655R0--Forward-to-LEWG-with-encouragement-to-add-analysis-of-overload-resolution-and-techniques-to-address-ambiguity-" class="self-link"></a></h4><p>Attendees: 8 (no abstentions)</p><p>8/0/0/0/0</p><p>Strong consensus.</p><h3 data-number="7.2.2" id="June-2025--Sofia-SG23"><span class="header-section-number">7.2.2</span> June 2025, Sofia SG23<a href="#June-2025--Sofia-SG23" class="self-link"></a></h3><h4 data-number="7.2.2.1" id="11-4-We-want-a-separate-bounded-array-constructor--prioritized-wrt-char--"><span class="header-section-number">7.2.2.1</span> 11.4 We want a separate bounded array constructor (prioritized wrt char)*<a href="#11-4-We-want-a-separate-bounded-array-constructor--prioritized-wrt-char--" class="self-link"></a></h4><p>6/5/0/0/1</p><p>Consensus</p><h4 data-number="7.2.2.2" id="11-5-We-want-to-forbid-constructing-assigning-zstring_view-containing-embedded-null-chars"><span class="header-section-number">7.2.2.2</span> 11.5 We want to forbid constructing/assigning zstring_view containing embedded null chars<a href="#11-5-We-want-to-forbid-constructing-assigning-zstring_view-containing-embedded-null-chars" class="self-link"></a></h4><p>3/6/0/0/3</p><p>Weak consensus</p><h4 data-number="7.2.2.3" id="We-want-to-drop-the-first-constructor-from-zstring_view-in-this-paper-taking-the-char---"><span class="header-section-number">7.2.2.3</span> We want to drop the first constructor from zstring_view in this paper taking the char*)*<a href="#We-want-to-drop-the-first-constructor-from-zstring_view-in-this-paper-taking-the-char---" class="self-link"></a></h4><p>2/3/3/0/2</p><p>No consensus</p><h3 data-number="7.2.3" id="June-2025--Sofia-LEWG"><span class="header-section-number">7.2.3</span> June 2025, Sofia LEWG<a href="#June-2025--Sofia-LEWG" class="self-link"></a></h3><h4 data-number="7.2.3.1" id="POLL--We-want-to-spend-more-time-on--zstring_view-"><span class="header-section-number">7.2.3.1</span> POLL: We want to spend more time on `zstring_view`<a href="#POLL--We-want-to-spend-more-time-on--zstring_view-" class="self-link"></a></h4><p>23/8/5/0/0</p><p>Attendance: 30 (IP) + 11 (R)</p><p>Author’s Position: 2xSF</p><p>Outcome: strong consensus in favour</p><h4 data-number="7.2.3.2" id="POLL--Rename--zstring_view--to--cstring_view-"><span class="header-section-number">7.2.3.2</span> POLL: Rename `zstring_view` to `cstring_view`<a href="#POLL--Rename--zstring_view--to--cstring_view-" class="self-link"></a></h4><p>8/6/13/4/2</p><p>Attendance: 30 (IP) + 11 (R)</p><p>Author’s Position: F, A</p><p>Outcome: No consensus.</p><h4 data-number="7.2.3.3" id="POLL---zstring_view--should-be-disallowed-to-have-NUL-characters-in-the-middle-"><span class="header-section-number">7.2.3.3</span> POLL: `zstring_view` should be disallowed to have NUL characters in the middle.<a href="#POLL---zstring_view--should-be-disallowed-to-have-NUL-characters-in-the-middle-" class="self-link"></a></h4><p>2/6/10/4/11</p><p>Attendance: 27 (IP) + 11 (R)</p><p>Author’s Position: F, A</p><p>Outcome: No consensus for change</p><h2 data-number="7.3" id="NVIDIA-Experience--moved-from-p3710-"><span class="header-section-number">7.3</span> NVIDIA Experience (moved from p3710)<a href="#NVIDIA-Experience--moved-from-p3710-" class="self-link"></a></h2><p>NVIDIA implemented <span class="code">cstring_view</span> independently, with almost identical features. This is described in <a href="P3710 cstring_view: a string_view with guaranteed null termination">https://wg21.link/p3710</a>, now merged into this paper. We also implemented some additional features described in <a href="P3566 You shall not pass char*">https://wg21.link/p3566</a>.</p><p>Ideally we wanted our input parameters to all be <span class="code">string_view</span> and all the output parameter to be <span class="code">cstring_view</span> (which gives more flexibility).</p><p>In practice, there are exceptions on both sides:</p><ul><li>When a null-terminated parameter is needed for internal reasons outside of our control, i.e. when interacting with system calls or third-party libraries, it's preferable to have a <span class="code">cstring_view</span> parameter.</li><li>When returning a part of an internal string, e.g. when extracting the file name from a full path, it's more convenient to just return a <span class="code">string_view</span>.</li></ul><p>Nonetheless, having a large codebase, we knew we couldn't just rewrite the entire codebase to apply this change, so we used <span class="code">cstring_view</span> as a tool for steering our codebase in the ideal direction described above.</p><p>Initially, we used as <span class="code">cstring_view</span> as a drop-in replacement for <span class="code"><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span></span> parameters and return values of our APIs, without worrying too much wether or not the function expects a null terminator. As a sidenote, for this migration we asked our developers to be intentional in using <span class="code"><span class="special">.</span>data<span class="special">()</span></span> or <span class="code"><span class="special">.</span>c_str<span class="special">()</span></span>, and use <span class="code"><span class="special">.</span>data<span class="special">()</span></span> when a null-terminator is not expected, and only use <span class="code"><span class="special">.</span>c_str<span class="special">()</span></span> when the string is required to be terminated. If respected, this rule allows us to just try changing a parameter from <span class="code">cstring_view</span> to <span class="code">string_view</span> and verify wether or not a function is relying on some parameter to be null-terminated. This operation can be done incrementally, one function at a time.</p><p>Once this was done, we started from the "deepest" functions to analyze their usage, and replace their parameters <span class="code">cstring_view</span> to <span class="code">string_view</span>, or rewrite them to allow for <span class="code">string_view</span> parameters. We proceeded upwards in the call chain, and did the same. Again, this can be done in multiple passes.</p><p>What we observed is that, in some case, this might not only make the code safer, but also enable new optimizations.</p><p>Here follows an example of a parameter upgrade how we implemented these changes, step-by-step, with an example of how this can lead to more performant and safer code at the end of the process.</p><code><div class="code"><span class="keyword">void</span> f<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> x<span class="special">)</span> <span class="special">{</span>
  external_library<span class="special">::</span>g1<span class="special">(</span>x<span class="special">);</span>
<span class="special">}</span>

<span class="keyword">void</span> f1<span class="special">()</span> <span class="special">{</span>
  std<span class="special">::</span>string a1 <span class="special">=</span> <span class="special">"</span>test<span class="special">";</span>
  f<span class="special">(</span>a1<span class="special">.</span>c_str<span class="special">());</span>
<span class="special">}</span>

<span class="keyword">void</span> f2<span class="special">()</span> <span class="special">{</span>
  <span class="keyword">constexpr</span> <span class="keyword">char</span> a2<span class="special">[]</span> <span class="special">=</span> <span class="special">"</span>test<span class="special">";</span>
  f<span class="special">(</span>a2<span class="special">);</span>
<span class="special">}</span>

<span class="keyword">void</span> f3<span class="special">()</span> <span class="special">{</span>
  <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> a3 <span class="special">=</span> <span class="special">"</span>test<span class="special">";</span>
  f<span class="special">(</span>a3<span class="special">);</span>
<span class="special">}</span>

<span class="keyword">void</span> f4<span class="special">()</span> <span class="special">{</span>
  string_view a4 <span class="special">=</span> <span class="special">"</span>abcde<span class="special">";</span>
  string_view subtext <span class="special">=</span> a4<span class="special">.</span>substr<span class="special">(</span>2<span class="special">,</span> 2<span class="special">);</span> <span class="comment">// no null terminator at the end of `subtext`</span><br>
  f<span class="special">(</span>string<span class="special">{</span>subtext<span class="special">});</span> <span class="comment">// create a temporary to add the terminator</span><br><span class="special">}</span></div></code><p>In this example, <span class="code">external_library<span class="special">::</span>g1</span> is a placeholder for some generic computation that happens on the string.</p><p>Initially, we update the API we will change f to:</p><code><div class="code"><span class="keyword">void</span> f<span class="special">(</span>cstring_view x<span class="special">)</span> <span class="special">{</span>
  external_library<span class="special">::</span>g1<span class="special">(</span>x<span class="special">.</span>c_str<span class="special">());</span>
<span class="special">}</span></div></code><p>All the functions now have well-defined memory ranges (no unbounded string).</p><p>We can now then look for alternatives, and find out there's a different API for the <span class="code">external_library<span class="special">::</span>g1</span> we can use, e.g. <span class="code">external_library<span class="special">::</span>g2<span class="special">(</span><span class="keyword">char</span><span class="special">*,</span> size_t<span class="special">)</span></span>, that doesn't require a null-terminated sequence.</p><code><div class="code"><span class="keyword">void</span> f<span class="special">(</span>string_view x<span class="special">)</span> <span class="special">{</span>
  external_library<span class="special">::</span>g2<span class="special">(</span>x<span class="special">.</span>data<span class="special">(),</span> x<span class="special">.</span>size<span class="special">());</span>
<span class="special">}</span></div></code><p>As next step, we can check all the usages, and see if we can get rid of some extra code, for example:</p><code><div class="code"><span class="keyword">void</span> f4<span class="special">()</span> <span class="special">{</span>
  string_view a4 <span class="special">=</span> <span class="special">"</span>abcde<span class="special">";</span>
  string_view subtext <span class="special">=</span> a4<span class="special">.</span>substr<span class="special">(</span>2<span class="special">,</span> 2<span class="special">);</span> <span class="comment">// no null terminator at the end of `subtext`</span><br>
  f<span class="special">(</span>subtext<span class="special">);</span> <span class="comment">// f now accepts a string_view, no need for temporary</span><br><span class="special">}</span></div></code><p>This results in a better-optimized code at the end (less need for temporary <span class="code">string</span>s).</p><p>NOTE: The sequence of changes in our codebase was different, because our codebase includes the changes proposed in <a href="P3566 You shall not pass char*">https://wg21.link/p3566</a>, so some of the intermediate steps relying on implicit <span class="code"><span class="keyword">char</span><span class="special">*</span></span> -&gt; <span class="code">string_view</span> and <span class="code"><span class="keyword">char</span><span class="special">*</span></span> -&gt; <span class="code">cstring_view</span> conversions require additional changes, and intermediate steps marking conversions with the proposed <span class="code">unsafe_length</span> tag.</p><h1 data-number="8" id="Wording"><span class="header-section-number">8</span> Wording<a href="#Wording" class="self-link"></a></h1><p>Changes in [format.formatter.spec] and [string.view.general] are deltas, all subsequent are full additions.</p><h2 data-number="8.1" id="-format-formatter-spec-"><span class="header-section-number">8.1</span> [format.formatter.spec]<a href="#-format-formatter-spec-" class="self-link"></a></h2><p>Add to 2.2:</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> traits<span class="special">&gt;</span>
  <span class="keyword">struct</span> formatter<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span><span class="special">,</span> charT<span class="special">&gt;</span><span class="special">;</span></div></code><p>Add to 4.1:</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> traits<span class="special">&gt;</span>
  <span class="keyword">struct</span> formatter<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> traits<span class="special">&gt;</span><span class="special">,</span> <span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="special">;</span></div></code><h2 data-number="8.2" id="String-View-Classes--string-view-"><span class="header-section-number">8.2</span> String View Classes [string.view]<a href="#String-View-Classes--string-view-" class="self-link"></a></h2><h3 data-number="8.2.1" id="General--string-view-general-"><span class="header-section-number">8.2.1</span> General [string.view.general]<a href="#General--string-view-general-" class="self-link"></a></h3><p>Update as indicated:</p><p>The class template basic_string_view describes an object that can refer to a constant contiguous sequence of char-like ([strings.general]) objects with the first element of the sequence at position zero. <span class="new">The class template basic_cstring_view describes an object that can refer to a constant contiguous sequence of char-like ([strings.general]) objects with the first element of the sequence at position zero, that is guaranteed to contain a null-terminator at the position <span class="code">size<span class="special">()</span></span>. </span> In the rest of [string.view], the type of the char-like objects held in a <span class="code">basic_string_view</span> <span class="new"> or a <span class="code">basic_cstring_view</span> </span> object is designated by <span class="code">charT</span>.</p><p><span class="new">For <span class="code">basic_string_view</span>, <span class="code"><span class="special">[</span>data<span class="special">(),</span> data<span class="special">()</span> <span class="special">+</span> size<span class="special">())</span></span> is a valid range. For <span class="code">basic_cstring_view</span>, <span class="code"><span class="special">[</span>data<span class="special">(),</span> data<span class="special">()</span> <span class="special">+</span> size<span class="special">()]</span></span> is a valid range and <span class="code">data<span class="special">()</span> <span class="special">+</span> size<span class="special">()</span></span> points at an object with value <span class="code">charT<span class="special">()</span></span> (a "null terminator").</span></p><p>[Note 1 : The library provides implicit conversions from const charT* and std::basic_string&lt;charT, ...&gt; to <span class="new">std::basic_cstring_view&lt;charT, ...&gt;, and implicit conversions from const char*, std::basic_string&lt;charT, ...&gt; and std::basic_cstring_view&lt;charT, ...&gt; to </span>std::basic_string_view&lt;charT, ...&gt; so that user code can accept just std::basic_string_view&lt;charT&gt; <span class="new"> or std::basic_cstring_view&lt;charT&gt; </span> as a non-templated parameter wherever a sequence of characters is expected. User-defined types can define their own implicit conversions to std::basic_string_view&lt;charT&gt; <span class="new"> or std::basic_cstring_view&lt;charT&gt; </span> in order to interoperate with these functions. — end note]</p><p><span class="new">[Note 2: <span class="code">basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> <span class="special">...</span><span class="special">&gt;</span></span> is primarily useful when working with C APIs which expect null terminated strings. - end note]</span></p><h4 data-number="8.2.1.1" id="Header-cstring_view--string-view-cstring_view-"><span class="header-section-number">8.2.1.1</span> Header cstring_view [string.view.cstring_view]<a href="#Header-cstring_view--string-view-cstring_view-" class="self-link"></a></h4><code><div class="code"><span class="keyword">namespace</span> std <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span>
  concept cstring_like <span class="special">=</span> requires<span class="special">(</span><span class="keyword">const</span> T <span class="special">&amp;</span> t<span class="special">)</span> <span class="special">{</span> <span class="special">{</span> t<span class="special">.</span>c_str<span class="special">()</span> <span class="special">}</span> <span class="special">-</span><span class="special">&gt;</span> std<span class="special">::</span>same_as<span class="special">&lt;</span><span class="keyword">const</span> T<span class="special">::</span>value_type<span class="special">*</span><span class="special">&gt;</span> <span class="special">};</span>

  <span class="comment">// [string.view.cstring_view.template], class template basic_cstring_view</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits <span class="special">=</span> char_traits<span class="special">&lt;</span>charT<span class="special">&gt;&gt;</span>
  <span class="keyword">class</span> basic_cstring_view<span class="special">;</span>                                              <span class="comment">// partially freestanding</span><br>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> ranges<span class="special">::</span>enable_view<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> ranges<span class="special">::</span>enable_borrowed_range<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>

  <span class="comment">// [string.view.cstring_view.comparison], non-member comparison functions</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">,</span>
                              type_identity_t<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> y<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> <span class="comment">/* see below */</span><br> <span class="keyword">operator</span><span class="special">&lt;</span><span class="special">=</span><span class="special">&gt;</span><span class="special">(</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">,</span>
                              type_identity_t<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> y<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

  <span class="comment">// [string.view.cstring_view.io], inserters and extractors</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
    basic_ostream<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&amp;</span>
      <span class="keyword">operator</span><span class="special">&lt;&lt;</span><span class="special">(</span>basic_ostream<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&amp;</span> os<span class="special">,</span>
                 basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> str<span class="special">);</span>                 <span class="comment">// hosted</span><br>
  <span class="comment">// basic_cstring_view typedef-names</span><br>  <span class="keyword">using</span> cstring_view    <span class="special">=</span> basic_cstring_view<span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">using</span> u8cstring_view  <span class="special">=</span> basic_cstring_view<span class="special">&lt;</span><span class="keyword">char8_t</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">using</span> u16cstring_view <span class="special">=</span> basic_cstring_view<span class="special">&lt;</span><span class="keyword">char16_t</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">using</span> u32cstring_view <span class="special">=</span> basic_cstring_view<span class="special">&lt;</span><span class="keyword">char32_t</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">using</span> wcstring_view   <span class="special">=</span> basic_cstring_view<span class="special">&lt;</span><span class="keyword">wchar_t</span><span class="special">&gt;</span><span class="special">;</span>

  <span class="comment">// [string.view.cstring_view.hash], hash support</span><br>  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> hash<span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u8cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u16cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u32cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>wcstring_view<span class="special">&gt;</span><span class="special">;</span>

  <span class="keyword">inline</span> <span class="keyword">namespace</span> literals <span class="special">{</span>
    <span class="keyword">inline</span> <span class="keyword">namespace</span> cstring_view_literals <span class="special">{</span>
      <span class="comment">// [string.view.cstring_view.literals], suffix for basic_cstring_view literals</span><br>      <span class="keyword">constexpr</span> cstring_view    <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
      <span class="keyword">constexpr</span> u8cstring_view  <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char8_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
      <span class="keyword">constexpr</span> u16cstring_view <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char16_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
      <span class="keyword">constexpr</span> u32cstring_view <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char32_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
      <span class="keyword">constexpr</span> wcstring_view   <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="special">}</span>
  <span class="special">}</span>
<span class="special">}</span></div></code><h3 data-number="8.2.2" id="Class-template-basic_cstring_view--string-view-cstring_view-template-"><span class="header-section-number">8.2.2</span> Class template basic_cstring_view [string.view.cstring_view.template]<a href="#Class-template-basic_cstring_view--string-view-cstring_view-template-" class="self-link"></a></h3><h4 data-number="8.2.2.1" id="General--string-view-cstring_view-template-general-"><span class="header-section-number">8.2.2.1</span> General [string.view.cstring_view.template.general]<a href="#General--string-view-cstring_view-template-general-" class="self-link"></a></h4><p>Add this whole section</p><code><div class="code"><span class="keyword">namespace</span> std <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits <span class="special">=</span> char_traits<span class="special">&lt;</span>charT<span class="special">&gt;&gt;</span>
  <span class="keyword">class</span> basic_cstring_view <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// types</span><br>    <span class="keyword">using</span> traits_type            <span class="special">=</span> traits<span class="special">;</span>
    <span class="keyword">using</span> value_type             <span class="special">=</span> charT<span class="special">;</span>
    <span class="keyword">using</span> pointer                <span class="special">=</span> value_type<span class="special">*;</span>
    <span class="keyword">using</span> const_pointer          <span class="special">=</span> <span class="keyword">const</span> value_type<span class="special">*;</span>
    <span class="keyword">using</span> reference              <span class="special">=</span> value_type<span class="special">&amp;</span><span class="special">;</span>
    <span class="keyword">using</span> const_reference        <span class="special">=</span> <span class="keyword">const</span> value_type<span class="special">&amp;</span><span class="special">;</span>
    <span class="keyword">using</span> const_iterator         <span class="special">=</span> implementation<span class="special">-</span>defined<span class="special">;</span> <span class="comment">// see [string.view.cstring_view.iterators]</span><br>    <span class="keyword">using</span> iterator               <span class="special">=</span> const_iterator<span class="special">;</span>
    <span class="keyword">using</span> const_reverse_iterator <span class="special">=</span> reverse_iterator<span class="special">&lt;</span>const_iterator<span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">using</span> reverse_iterator       <span class="special">=</span> const_reverse_iterator<span class="special">;</span>
    <span class="keyword">using</span> size_type              <span class="special">=</span> size_t<span class="special">;</span>
    <span class="keyword">using</span> difference_type        <span class="special">=</span> ptrdiff_t<span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">constexpr</span> size_type npos <span class="special">=</span> size_type<span class="special">(-</span>1<span class="special">);</span>

    <span class="comment">// [string.view.cstring_view.cons], construction and assignment</span><br>    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    basic_cstring_view<span class="special">(</span><span class="keyword">const</span> basic_cstring_view<span class="special">&amp;</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
    basic_cstring_view<span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> basic_cstring_view<span class="special">&amp;</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">)</span> <span class="keyword">noexcept</span>
              <span class="keyword">pre</span><span class="special">(</span>str <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">,</span> size_type len<span class="special">)</span> <span class="keyword">noexcept</span>
              <span class="keyword">pre</span><span class="special">(</span>str <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">)</span> 
              <span class="keyword">pre</span><span class="special">(</span>str<span class="special">[</span>len<span class="special">]</span> <span class="special">==</span> <span class="special">'\</span>0<span class="special">');</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> It<span class="special">,</span> <span class="keyword">class</span> End<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span>It begin<span class="special">,</span> End end<span class="special">)</span>
              <span class="keyword">pre</span><span class="special">(*(</span>begin <span class="special">+</span> <span class="special">(</span>end <span class="special">-</span> begin<span class="special">))</span> <span class="special">==</span> charT<span class="special">());</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> R<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span>cstring_like R<span class="special">&amp;&amp;</span> r<span class="special">);</span>

    <span class="comment">// [string.view.cstring_view.iterators], iterator support</span><br>    <span class="keyword">constexpr</span> const_iterator begin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_iterator end<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_iterator cbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_iterator cend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reverse_iterator rbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reverse_iterator rend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reverse_iterator crbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reverse_iterator crend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// [string.view.cstring_view.capacity], capacity</span><br>    <span class="keyword">constexpr</span> size_type size<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type length<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type max_size<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="special">[[</span>nodiscard<span class="special">]]</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> empty<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// [string.view.cstring_view.access], element access</span><br>    <span class="keyword">constexpr</span> const_reference <span class="keyword">operator</span><span class="special">[](</span>size_type pos<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>pos <span class="special">&lt;</span><span class="special">=</span> size<span class="special">());</span>
    <span class="keyword">constexpr</span> const_reference at<span class="special">(</span>size_type pos<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reference front<span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_reference back<span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_pointer data<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> const_pointer c_str<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// [string.view.cstring_view.modifiers], modifiers</span><br>    <span class="keyword">constexpr</span> <span class="keyword">void</span> remove_prefix<span class="special">(</span>size_type n<span class="special">);</span>
    <span class="keyword">constexpr</span> <span class="keyword">void</span> remove_suffix<span class="special">(</span>size_type n<span class="special">)</span> 
        <span class="special">=</span> <span class="keyword">delete</span><span class="special">("</span>cannot remove_suffix in<span class="special">-</span>place on cstring_view <span class="keyword">while</span> retaining null terminator<span class="special">.</span> Use substr instead<span class="special">.");</span>
    <span class="keyword">constexpr</span> <span class="keyword">void</span> swap<span class="special">(</span>basic_cstring_view<span class="special">&amp;</span> s<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="comment">// [string.view.cstring_view.ops], cstring operations</span><br>    <span class="keyword">constexpr</span> size_type copy<span class="special">(</span>charT<span class="special">*</span> s<span class="special">,</span> size_type n<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> substr<span class="special">(</span>size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> subview<span class="special">(</span>size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">constexpr</span> basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> substr<span class="special">(</span>size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> subview<span class="special">(</span>size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> basic_string_view s<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> basic_string_view s<span class="special">,</span>
                          size_type pos2<span class="special">,</span> size_type n2<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> <span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> <span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type n2<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>x <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>x <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>x <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="comment">// [string.view.cstring_view.find], searching</span><br>    <span class="keyword">constexpr</span> size_type find<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type rfind<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type rfind<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type rfind<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type rfind<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="keyword">constexpr</span> size_type find_first_of<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_first_of<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_first_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_first_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_last_of<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_last_of<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_last_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_last_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_first_not_of<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_first_not_of<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_first_not_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span>
                                          size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_first_not_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_last_not_of<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span>
                                         size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_last_not_of<span class="special">(</span>charT c<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">constexpr</span> size_type find_last_not_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span>
                                         size_type n<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="keyword">constexpr</span> size_type find_last_not_of<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos <span class="special">=</span> npos<span class="special">)</span> <span class="keyword">const</span>
              <span class="keyword">pre</span> <span class="special">(</span>s <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

  <span class="keyword">private</span><span class="special">:</span>
    const_pointer data_<span class="special">;</span>        <span class="comment">// exposition only</span><br>    size_type size_<span class="special">;</span>            <span class="comment">// exposition only</span><br>  <span class="special">};</span>
<span class="special">}</span></div></code><h4 data-number="8.2.2.2" id="Construction-and-assignment--string-view-cstring_view-cons-"><span class="header-section-number">8.2.2.2</span> Construction and assignment [string.view.cstring_view.cons]<a href="#Construction-and-assignment--string-view-cstring_view-cons-" class="self-link"></a></h4><p><span class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span></span></p><p>Effects: Constructs an empty basic_cstring_view.</p><p>Postconditions: size_ is 0 and data_ points to a valid empty string</p><p>Complexity: O(1).</p><p><span class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></span></p><p>Preconditions: [str, str + traits::length(str)] is a valid range, str[traits::length(str)] == charT()</p><p>Effects: Constructs a basic_cstring_view that refers to str.</p><p>Postconditions: size_ returns traits::length(str) and data_ returns str.</p><p>Complexity: O(traits::length(str)).</p><p><span class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> str<span class="special">,</span> size_type len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></span></p><p>Preconditions: [str, str + len] is a valid range, str[len] == charT().</p><p>Effects: Constructs a basic_cstring_view that refers to str.</p><p>Postconditions: size_ returns len and data_ returns str.</p><p>Complexity: O(1).</p><code><div class="code">    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> It<span class="special">,</span> <span class="keyword">class</span> End<span class="special">&gt;</span>
    <span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span>It begin<span class="special">,</span> End end<span class="special">);</span></div></code><p>Constraints:</p><p>— It satisfies contiguous_iterator.</p><p>— End satisfies sized_sentinel_for&lt;It&gt;.</p><p>— is_same_v&lt;iter_value_t&lt;It&gt;, charT&gt; is true.</p><p>— is_convertible_v&lt;End, size_type&gt; is false.</p><p>Preconditions:</p><p>— [begin, end] is a valid range.</p><p>— It models contiguous_iterator.</p><p>— End models sized_sentinel_for&lt;It&gt;.</p><p>— *(begin + (end - begin)) == charT()</p><p>Effects: Creates a basic_cstring_view that refers to the range from begin to end, inclusive.</p><p>Postconditions: size_ returns (end - begin) and data_ returns to_address(begin).</p><p>Throws: When and what end - begin throws.</p><p>Complexity: O(1).</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> R<span class="special">&gt;</span>
<span class="keyword">constexpr</span> basic_cstring_view<span class="special">(</span>cstring_like R<span class="special">&amp;&amp;</span> r<span class="special">);</span></div></code><p>Let d be an lvalue of type remove_cvref_t&lt;R&gt;.</p><p>Constraints:</p><p>— remove_cvref_t&lt;R&gt; is not the same type as basic_cstring_view,</p><p>— R models ranges::contiguous_range, ranges::sized_range and cstring_like</p><p>— is_same_v&lt;ranges::range_value_t&lt;R&gt;, charT&gt; is true,</p><p>— is_convertible_v&lt;R, const charT*&gt; is false, and</p><p>— d.operator ::std::basic_cstring_view&lt;charT, traits&gt;() is not a valid expression.</p><p>Effects: Creates a basic_cstring_view that refers to the range specified by r.</p><p>Postconditions: size_ returns ranges::size(r) and data_ returns ranges::data(r).</p><p>Throws: Any exception thrown by ranges::data(r) and ranges::size(r).</p><h4 data-number="8.2.2.3" id="Deduction-guides--string-view-cstring_view-deduct-"><span class="header-section-number">8.2.2.3</span> Deduction guides (string.view.cstring_view.deduct]<a href="#Deduction-guides--string-view-cstring_view-deduct-" class="self-link"></a></h4><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> It<span class="special">,</span> <span class="keyword">class</span> End<span class="special">&gt;</span>
basic_string_view<span class="special">(</span>It<span class="special">,</span> End<span class="special">)</span> <span class="special">-</span><span class="special">&gt;</span> basic_string_view<span class="special">&lt;</span>iter_value_t<span class="special">&lt;</span>It<span class="special">&gt;&gt;</span><span class="special">;</span></div></code><p>Constraints:</p><p>— It satisfies contiguous_iterator.</p><p>— End satisfies sized_sentinel_for&lt;It&gt;.</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> R<span class="special">&gt;</span>
basic_string_view<span class="special">(</span>cstring_like R<span class="special">&amp;&amp;</span><span class="special">)</span> <span class="special">-</span><span class="special">&gt;</span> basic_string_view<span class="special">&lt;</span>ranges<span class="special">::</span>range_value_t<span class="special">&lt;</span>R<span class="special">&gt;&gt;</span><span class="special">;</span></div></code><p>Constraints: R satisfies ranges::contiguous_range and cstring_like</p><h4 data-number="8.2.2.4" id="Iterator-support--string-view-cstring_view-iterators-"><span class="header-section-number">8.2.2.4</span> Iterator support [string.view.cstring_view.iterators]<a href="#Iterator-support--string-view-cstring_view-iterators-" class="self-link"></a></h4><code><div class="code"><span class="keyword">constexpr</span> const_iterator begin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> const_iterator cbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: An iterator such that addressof(*begin()) == data_.</p><code><div class="code"><span class="keyword">constexpr</span> const_iterator end<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> const_iterator cend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: begin() + size_.</p><code><div class="code"><span class="keyword">constexpr</span> const_reverse_iterator rbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> const_reverse_iterator crbegin<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: const_reverse_iterator(end()).</p><code><div class="code"><span class="keyword">constexpr</span> const_reverse_iterator rend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> const_reverse_iterator crend<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: const_reverse_iterator(begin()).</p><h4 data-number="8.2.2.5" id="Capacity--string-view-cstring_view-capacity-"><span class="header-section-number">8.2.2.5</span> Capacity [string.view.cstring_view.capacity]<a href="#Capacity--string-view-cstring_view-capacity-" class="self-link"></a></h4><code><div class="code"><span class="keyword">constexpr</span> size_type size<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> size_type length<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: size_.</p><code><div class="code"><span class="keyword">constexpr</span> size_type max_size<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: The largest possible number of char-like objects that can be referred to by a basic_cstring_view.</p><code><div class="code"><span class="special">[[</span>nodiscard<span class="special">]]</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> empty<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: size_ == 0.</p><h4 data-number="8.2.2.6" id="Element-access--string-view-cstring_view-access-"><span class="header-section-number">8.2.2.6</span> Element access [string.view.cstring_view.access]<a href="#Element-access--string-view-cstring_view-access-" class="self-link"></a></h4><code><div class="code"><span class="keyword">constexpr</span> const_reference <span class="keyword">operator</span><span class="special">[](</span>size_type pos<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Hardened preconditions: pos &lt;= size_ is true.</p><p>[Note: This precondition is identical to basic_string::operator[]. — end note]</p><p>Returns: data_[pos].</p><p>Throws: Nothing.</p><code><div class="code"><span class="keyword">constexpr</span> const_reference at<span class="special">(</span>size_type pos<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Returns: data_[pos].</p><p>Throws: out_of_range if pos &gt; size_.</p><code><div class="code"><span class="keyword">constexpr</span> const_reference front<span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Hardened preconditions: empty() is false.</p><p>Returns: data_[0].</p><p>Throws: Nothing.</p><code><div class="code"><span class="keyword">constexpr</span> const_reference back<span class="special">()</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Hardened preconditions: empty() is false.</p><p>Returns: data_[size_-1].</p><p>Throws: Nothing.</p><code><div class="code"><span class="keyword">constexpr</span> const_pointer data<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> const_pointer c_str<span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: data_.</p><p>[Note: The pointer returned is safe to pass to any function expecting a null-terminated string]</p><p>Postcondition: The returned value can be dereferenced in [0, size()].</p><h4 data-number="8.2.2.7" id="Modifiers--string-view-cstring_view-modifiers-"><span class="header-section-number">8.2.2.7</span> Modifiers [string.view.cstring_view.modifiers]<a href="#Modifiers--string-view-cstring_view-modifiers-" class="self-link"></a></h4><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">void</span> remove_prefix<span class="special">(</span>size_type n<span class="special">);</span></div></code><p>Hardened preconditions: n &lt;= size() is true.</p><p>Effects: Equivalent to: data_ += n; size_ -= n;</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">void</span> swap<span class="special">(</span>basic_cstring_view<span class="special">&amp;</span> s<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Effects: Exchanges the values of *this and s.</p><h4 data-number="8.2.2.8" id="String-operations--string-view-cstring_view-ops-"><span class="header-section-number">8.2.2.8</span> String operations [string.view.cstring_view.ops]<a href="#String-operations--string-view-cstring_view-ops-" class="self-link"></a></h4><code><div class="code"><span class="keyword">constexpr</span> size_type copy<span class="special">(</span>charT<span class="special">*</span> s<span class="special">,</span> size_type n<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Let rlen be the smaller of n and size() - pos.</p><p>Preconditions: [s, s + rlen) is a valid range.</p><p>Effects: Equivalent to traits::copy(s, data() + pos, rlen).</p><p>Returns: rlen.</p><p>Throws: out_of_range if pos &gt; size().</p><p>Complexity: O(rlen).</p><code><div class="code"><span class="keyword">constexpr</span> basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> substr<span class="special">(</span>size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">constexpr</span> basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> subview<span class="special">(</span>size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Returns: basic_cstring_view(data() + pos, size() - pos).</p><p>Throws: out_of_range if pos &gt; size().</p><code><div class="code"><span class="keyword">constexpr</span> basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> substr<span class="special">(</span>size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="keyword">constexpr</span> basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> subview<span class="special">(</span>size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Let rlen be the smaller of n and size() - pos.</p><p>Effects: Determines rlen, the effective length of the string to reference.</p><p>Returns: basic_cstring_view(data() + pos, rlen).</p><p>Throws: out_of_range if pos &gt; size().</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>basic_string_view str<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: Equivalent to: return substr(0).compare(str);</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> basic_string_view str<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return substr(pos1, n1).compare(str);</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> basic_string_view str<span class="special">,</span> size_type pos2<span class="special">,</span> size_type n2<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return substr(pos1, n1).compare(str.substr(pos2, n2));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return compare(basic_string_view&lt;charT, traits&gt;(s));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> <span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return substr(pos1, n1).compare(basic_string_view&lt;charT, traits&gt;(s));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">int</span> compare<span class="special">(</span>size_type pos1<span class="special">,</span> size_type n1<span class="special">,</span> <span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type n2<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return substr(pos1, n1).compare(basic_string_view&lt;charT, traits&gt;(s, n2));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Let rlen be the smaller of size() and x.size().</p><p>Effects: Equivalent to: return basic_string_view&lt;charT, traits&gt;(data(), rlen) == x;</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return !empty() && traits::eq(front(), x);</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> starts_with<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return starts_with(basic_string_view&lt;charT, traits&gt;(x));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Let rlen be the smaller of size() and x.size().</p><p>Effects: Equivalent to: return basic_string_view(data() + (size() - rlen), rlen) == x;</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Effects: Equivalent to: return !empty() && traits::eq(back(), x);</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> ends_with<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span></div></code><p>Effects: Equivalent to: return ends_with(basic_string_view(x));</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span>charT x<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> contains<span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> x<span class="special">)</span> <span class="keyword">const</span>
          <span class="keyword">pre</span> <span class="special">(</span>x <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span></div></code><p>Effects: Equivalent to: return find(x) != npos;</p><h4 data-number="8.2.2.9" id="Searching--string-view-cstring_view-find-"><span class="header-section-number">8.2.2.9</span> Searching [string.view.cstring_view.find]<a href="#Searching--string-view-cstring_view-find-" class="self-link"></a></h4><p>Member functions in this subclause have complexity O(size() * str.size()) at worst, although implementations should do better.</p><p>Let F be one of find, rfind, find_first_of, find_last_of, find_first_not_of, and find_last_not_of.</p><p>— Each member function of the form</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">return</span><span class="special">-</span>type F <span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>has effects equivalent to: return F (basic_string_view(s), pos);</p><p>— Each member function of the form</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">return</span><span class="special">-</span>type F <span class="special">(</span><span class="keyword">const</span> charT<span class="special">*</span> s<span class="special">,</span> size_type pos<span class="special">,</span> size_type n<span class="special">)</span> <span class="keyword">const</span><span class="special">;</span></div></code><p>has effects equivalent to: return F (basic_string_view(s, n), pos);</p><p>— Each member function of the form</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">return</span><span class="special">-</span>type F <span class="special">(</span>charT c<span class="special">,</span> size_type pos<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>has effects equivalent to: return F (basic_string_view(addressof(c), 1), pos);</p><p>— Each member function of the form</p><code><div class="code"><span class="keyword">constexpr</span> <span class="keyword">return</span><span class="special">-</span>type F <span class="special">(</span>basic_string_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> s<span class="special">,</span> size_type pos <span class="special">=</span> 0<span class="special">)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>has effects equivalent to: return basic_string_view&lt;charT, traits&gt;(*this).F(s, pos);</p><h3 data-number="8.2.3" id="Non-member-comparison-functions---string-view-cstring_view-comparison-"><span class="header-section-number">8.2.3</span> Non-member comparison functions, [string.view.cstring_view.comparison]<a href="#Non-member-comparison-functions---string-view-cstring_view-comparison-" class="self-link"></a></h3><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
  <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">,</span>
                            type_identity_t<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> y<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: lhs.compare(rhs) == 0.</p><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
  <span class="keyword">constexpr</span> <span class="comment">/* see below */</span><br> <span class="keyword">operator</span><span class="special">&lt;</span><span class="special">=</span><span class="special">&gt;</span><span class="special">(</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> x<span class="special">,</span>
                            type_identity_t<span class="special">&lt;</span>basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&gt;</span> y<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: Equivalent to: return lhs.substr().operator&lt;=&gt;(rhs);</p><h3 data-number="8.2.4" id="Inserters-and-extractors---string-view-cstring_view-io-"><span class="header-section-number">8.2.4</span> Inserters and extractors, [string.view.cstring_view.io]<a href="#Inserters-and-extractors---string-view-cstring_view-io-" class="self-link"></a></h3><code><div class="code"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> charT<span class="special">,</span> <span class="keyword">class</span> traits<span class="special">&gt;</span>
  basic_ostream<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&amp;</span>
    <span class="keyword">operator</span><span class="special">&lt;&lt;</span><span class="special">(</span>basic_ostream<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;&amp;</span> os<span class="special">,</span>
               basic_cstring_view<span class="special">&lt;</span>charT<span class="special">,</span> traits<span class="special">&gt;</span> str<span class="special">);</span></div></code><p>Returns: Equivalent to: return os &lt;&lt; str.substr();</p><h3 data-number="8.2.5" id="Hash-support---string-view-cstring_view-hash-"><span class="header-section-number">8.2.5</span> Hash support, [string.view.cstring_view.hash]<a href="#Hash-support---string-view-cstring_view-hash-" class="self-link"></a></h3><code><div class="code"><span class="keyword">namespace</span> std <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u8cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u16cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>u32cstring_view<span class="special">&gt;</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;&gt;</span> <span class="keyword">struct</span> hash<span class="special">&lt;</span>wcstring_view<span class="special">&gt;</span><span class="special">;</span>
<span class="special">}</span></div></code><p>The specialization is enabled.</p><p>[Note: The hash value of a string view object is equal to the hash value of the corresponding string object [basic.string.hash]. — end note]</p><h3 data-number="8.2.6" id="Suffix-for-basic_cstring_view-literals---string-view-cstring_view-literals-"><span class="header-section-number">8.2.6</span> Suffix for basic_cstring_view literals, [string.view.cstring_view.literals]<a href="#Suffix-for-basic_cstring_view-literals---string-view-cstring_view-literals-" class="self-link"></a></h3><code><div class="code"><span class="keyword">consteval</span> cstring_view    <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: cstring_view{str, len}.</p><code><div class="code"><span class="keyword">consteval</span> u8cstring_view  <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char8_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: u8cstring_view{str, len}.</p><code><div class="code"><span class="keyword">consteval</span> u16cstring_view <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char16_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: u16cstring_view{str, len}.</p><code><div class="code"><span class="keyword">consteval</span> u32cstring_view <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">char32_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: u32cstring_view{str, len}.</p><code><div class="code"><span class="keyword">consteval</span> wcstring_view   <span class="keyword">operator</span><span class="special">""</span>csv<span class="special">(</span><span class="keyword">const</span> <span class="keyword">wchar_t</span><span class="special">*</span> str<span class="special">,</span> size_t len<span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span></div></code><p>Returns: wcstring_view{str, len}.</p></body></html>
